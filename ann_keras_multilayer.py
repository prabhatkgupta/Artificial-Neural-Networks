# -*- coding: utf-8 -*-
"""ANN_Keras_MultiLayer

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A1AwpcmUlMREfB1vabkL3sNCgcEUOaOS
"""

import numpy as np
import h5py
import tensorflow as tf
import matplotlib.pyplot as plt
import os
import keras
from keras.layers import *
from keras.regularizers import *
from keras.optimizers import *

# %matplotlib inline

os.chdir('drive/My Drive/Dataset')

def Load_Data():
  
  train_dataset = h5py.File('train_signs.h5','r')
  test_dataset = h5py.File('test_signs.h5','r')
  
  train_set_X_orig = np.array(train_dataset['train_set_x'][:])
  train_set_Y_orig = np.array(train_dataset['train_set_y'][:])
  test_set_X_orig = np.array(test_dataset['test_set_x'][:])
  test_set_Y_orig = np.array(test_dataset['test_set_y'][:])
  
  classes = np.array(test_dataset['list_classes'][:])
  
  return train_set_X_orig,train_set_Y_orig,test_set_X_orig,test_set_Y_orig,classes

train_set_X_orig,train_set_Y_orig,test_set_X_orig,test_set_Y_orig,classes = Load_Data()

print(train_set_X_orig.shape,train_set_Y_orig.shape,test_set_X_orig.shape,test_set_Y_orig.shape)
i = 10
plt.imshow(test_set_X_orig[i])
print('y = '+str(test_set_Y_orig[i])+'. It is the number '+str(test_set_Y_orig[i]))

def Reshape_And_Normalize(train_set_X_orig,train_set_Y_orig,test_set_X_orig,test_set_Y_orig):
  
  m_train = train_set_X_orig.shape[0]
  m_test = test_set_X_orig.shape[0]
  train_set_X = train_set_X_orig.reshape(m_train,-1)
  test_set_X = test_set_X_orig.reshape(m_test,-1)

  train_set_Y = train_set_Y_orig.reshape((m_train,1))
  test_set_Y = test_set_Y_orig.reshape((m_test,1))
  
  U_train = np.sum(train_set_X,axis=1,keepdims=True)/m_train
  U_test = np.sum(test_set_X,axis=1,keepdims=True)/m_test
  
  train_set_X = train_set_X - U_train
  test_set_X = test_set_X - U_test
  
  sigma_train = np.sqrt(np.sum(np.square(train_set_X),axis=1,keepdims=True)/m_train)
  sigma_test = np.sqrt(np.sum(np.square(test_set_X),axis=1,keepdims=True)/m_test)
  
  train_set_X /= sigma_train
  test_set_X /= sigma_test
  
  return train_set_X,train_set_Y,test_set_X,test_set_Y

def Data_Preprocessing():
  
  train_set_X_orig,train_set_Y_orig,test_set_X_orig,test_set_Y_orig,classes = Load_Data()
  train_set_X,train_set_Y,test_set_X,test_set_Y = Reshape_And_Normalize(train_set_X_orig,train_set_Y_orig,test_set_X_orig,test_set_Y_orig)
  
  return train_set_X,train_set_Y,test_set_X,test_set_Y

def Propagation(layers_dims,regu,lambd,keep_prob):
  
  model = keras.models.Sequential()
  L = len(layers_dims)
  if(regu):
    lambd = lambd
  else:
    lambd = 0.0
  
  for l in range(1,L):
    
    if(l < L-1):
      activation = 'relu'
    else:
      if(layers_dims[l] == 1):
        activation = 'sigmoid'
      else:
        activation = 'softmax'
     
    model.add(BatchNormalization(axis=1,name='BatchNorm_F'+str(l+1)))
    model.add(Dense(layers_dims[l],activation=activation,kernel_initializer='glorot_uniform', bias_initializer='zeros',name='FullyConnected'+str(l+1),use_bias=True,kernel_regularizer=l2(0.01)))
    model.add(Dropout(rate=keep_prob[l-1]))
  
  return model

def Caller_Function():
  
  train_set_X,train_set_Y,test_set_X,test_set_Y = Data_Preprocessing()
  epochs = 10
  regu = False
  lambd = 0.01
  mini_batch_size = 10
  layers_dims = [train_set_X.shape[1]]
  layers_dims.extend([1024,6])
  keep_prob = [1,1]
  train_set_Y = np.eye(layers_dims[len(layers_dims)-1])[train_set_Y.T][0]
  test_set_Y = np.eye(layers_dims[len(layers_dims)-1])[test_set_Y.T][0]
  
  model = Propagation(layers_dims,regu,lambd,keep_prob)
  opt = Adam(lr=0.05)
  model.compile(loss='categorical_crossentropy',optimizer=opt,metrics=['accuracy'])
  model.fit(x=train_set_X[0:50,:],y=train_set_Y[0:50,:],epochs=epochs,batch_size=mini_batch_size)
  print('')
  preds = model.evaluate(x=train_set_X[0:10,:],y=train_set_Y[0:10,:])
  print("Train_Accuracy : "+str(preds[1]*100))
  print('')
  preds = model.evaluate(x=test_set_X[0:10,:],y=test_set_Y[0:10,:])
  print("Test_Accuracy : "+str(preds[1]*100))
  
  model.summary()
  print(model.predict(x=test_set_X[10:11,:]))

Caller_Function()

